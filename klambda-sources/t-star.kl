"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.typecheck (V3703 V3704) (let Curry (shen.curry V3703) (let ProcessN (shen.start-new-prolog-process) (let Type (shen.insert-prolog-variables (shen.demodulate (shen.curry-type V3704)) ProcessN) (let Continuation (freeze (return Type ProcessN shen.void)) (shen.t* (cons Curry (cons : (cons Type ()))) () ProcessN Continuation))))))

(defun shen.curry (V3706) (cond ((and (cons? V3706) (shen.special? (hd V3706))) (cons (hd V3706) (map (lambda Y (shen.curry Y)) (tl V3706)))) ((and (cons? V3706) (and (cons? (tl V3706)) (shen.extraspecial? (hd V3706)))) V3706) ((and (cons? V3706) (and (= type (hd V3706)) (and (cons? (tl V3706)) (and (cons? (tl (tl V3706))) (= () (tl (tl (tl V3706)))))))) (cons type (cons (shen.curry (hd (tl V3706))) (tl (tl V3706))))) ((and (cons? V3706) (and (cons? (tl V3706)) (cons? (tl (tl V3706))))) (shen.curry (cons (cons (hd V3706) (cons (hd (tl V3706)) ())) (tl (tl V3706))))) ((and (cons? V3706) (and (cons? (tl V3706)) (= () (tl (tl V3706))))) (cons (shen.curry (hd V3706)) (cons (shen.curry (hd (tl V3706))) ()))) (true V3706)))

(defun shen.special? (V3708) (element? V3708 (value shen.*special*)))

(defun shen.extraspecial? (V3710) (element? V3710 (value shen.*extraspecial*)))

(defun shen.t* (V3715 V3716 V3717 V3718) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let Error (shen.newpv V3717) (do (shen.incinfs) (fwhen (shen.maxinfexceeded?) V3717 (freeze (bind Error (shen.errormaxinfs) V3717 V3718))))) (if (= Case false) (let Case (let V3695 (shen.lazyderef V3715 V3717) (if (= fail V3695) (do (shen.incinfs) (cut Throwcontrol V3717 (freeze (shen.prolog-failure V3717 V3718)))) false)) (if (= Case false) (let Case (let V3696 (shen.lazyderef V3715 V3717) (if (cons? V3696) (let X (hd V3696) (let V3697 (shen.lazyderef (tl V3696) V3717) (if (cons? V3697) (let V3698 (shen.lazyderef (hd V3697) V3717) (if (= : V3698) (let V3699 (shen.lazyderef (tl V3697) V3717) (if (cons? V3699) (let A (hd V3699) (let V3700 (shen.lazyderef (tl V3699) V3717) (if (= () V3700) (do (shen.incinfs) (fwhen (shen.type-theory-enabled?) V3717 (freeze (cut Throwcontrol V3717 (freeze (shen.th* X A V3716 V3717 V3718)))))) false))) false)) false)) false))) false)) (if (= Case false) (let Datatypes (shen.newpv V3717) (do (shen.incinfs) (shen.show V3715 V3716 V3717 (freeze (bind Datatypes (value shen.*datatypes*) V3717 (freeze (shen.udefs* V3715 V3716 Datatypes V3717 V3718))))))) Case)) Case)) Case)))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun enable-type-theory (V3724) (cond ((= + V3724) (set shen.*shen-type-theory-enabled?* true)) ((= - V3724) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun shen.prolog-failure (V3735 V3736) false)

(defun shen.maxinfexceeded? () (> (inferences) (value shen.*maxinferences*)))

(defun shen.errormaxinfs () (simple-error "maximum inferences exceeded~%"))

(defun shen.udefs* (V3742 V3743 V3744 V3745 V3746) (let Case (let V3691 (shen.lazyderef V3744 V3745) (if (cons? V3691) (let D (hd V3691) (do (shen.incinfs) (call (cons D (cons V3742 (cons V3743 ()))) V3745 V3746))) false)) (if (= Case false) (let V3692 (shen.lazyderef V3744 V3745) (if (cons? V3692) (let Ds (tl V3692) (do (shen.incinfs) (shen.udefs* V3742 V3743 Ds V3745 V3746))) false)) Case)))

(defun shen.th* (V3752 V3753 V3754 V3755 V3756) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (do (shen.incinfs) (shen.show (cons V3752 (cons : (cons V3753 ()))) V3754 V3755 (freeze (fwhen false V3755 V3756)))) (if (= Case false) (let Case (let F (shen.newpv V3755) (do (shen.incinfs) (fwhen (shen.typedf? (shen.lazyderef V3752 V3755)) V3755 (freeze (bind F (shen.sigf (shen.lazyderef V3752 V3755)) V3755 (freeze (call (cons F (cons V3753 ())) V3755 V3756))))))) (if (= Case false) (let Case (do (shen.incinfs) (shen.base V3752 V3753 V3755 V3756)) (if (= Case false) (let Case (do (shen.incinfs) (shen.by_hypothesis V3752 V3753 V3754 V3755 V3756)) (if (= Case false) (let Case (let V3587 (shen.lazyderef V3752 V3755) (if (cons? V3587) (let F (hd V3587) (let V3588 (shen.lazyderef (tl V3587) V3755) (if (= () V3588) (do (shen.incinfs) (shen.th* F (cons --> (cons V3753 ())) V3754 V3755 V3756)) false))) false)) (if (= Case false) (let Case (let V3589 (shen.lazyderef V3752 V3755) (if (cons? V3589) (let F (hd V3589) (let V3590 (shen.lazyderef (tl V3589) V3755) (if (cons? V3590) (let X (hd V3590) (let V3591 (shen.lazyderef (tl V3590) V3755) (if (= () V3591) (let B (shen.newpv V3755) (do (shen.incinfs) (shen.th* F (cons B (cons --> (cons V3753 ()))) V3754 V3755 (freeze (shen.th* X B V3754 V3755 V3756))))) false))) false))) false)) (if (= Case false) (let Case (let V3592 (shen.lazyderef V3752 V3755) (if (cons? V3592) (let V3593 (shen.lazyderef (hd V3592) V3755) (if (= cons V3593) (let V3594 (shen.lazyderef (tl V3592) V3755) (if (cons? V3594) (let X (hd V3594) (let V3595 (shen.lazyderef (tl V3594) V3755) (if (cons? V3595) (let Y (hd V3595) (let V3596 (shen.lazyderef (tl V3595) V3755) (if (= () V3596) (let V3597 (shen.lazyderef V3753 V3755) (if (cons? V3597) (let V3598 (shen.lazyderef (hd V3597) V3755) (if (= list V3598) (let V3599 (shen.lazyderef (tl V3597) V3755) (if (cons? V3599) (let A (hd V3599) (let V3600 (shen.lazyderef (tl V3599) V3755) (if (= () V3600) (do (shen.incinfs) (shen.th* X A V3754 V3755 (freeze (shen.th* Y (cons list (cons A ())) V3754 V3755 V3756)))) (if (shen.pvar? V3600) (do (shen.bindv V3600 () V3755) (let Result (do (shen.incinfs) (shen.th* X A V3754 V3755 (freeze (shen.th* Y (cons list (cons A ())) V3754 V3755 V3756)))) (do (shen.unbindv V3600 V3755) Result))) false)))) (if (shen.pvar? V3599) (let A (shen.newpv V3755) (do (shen.bindv V3599 (cons A ()) V3755) (let Result (do (shen.incinfs) (shen.th* X A V3754 V3755 (freeze (shen.th* Y (cons list (cons A ())) V3754 V3755 V3756)))) (do (shen.unbindv V3599 V3755) Result)))) false))) (if (shen.pvar? V3598) (do (shen.bindv V3598 list V3755) (let Result (let V3601 (shen.lazyderef (tl V3597) V3755) (if (cons? V3601) (let A (hd V3601) (let V3602 (shen.lazyderef (tl V3601) V3755) (if (= () V3602) (do (shen.incinfs) (shen.th* X A V3754 V3755 (freeze (shen.th* Y (cons list (cons A ())) V3754 V3755 V3756)))) (if (shen.pvar? V3602) (do (shen.bindv V3602 () V3755) (let Result (do (shen.incinfs) (shen.th* X A V3754 V3755 (freeze (shen.th* Y (cons list (cons A ())) V3754 V3755 V3756)))) (do (shen.unbindv V3602 V3755) Result))) false)))) (if (shen.pvar? V3601) (let A (shen.newpv V3755) (do (shen.bindv V3601 (cons A ()) V3755) (let Result (do (shen.incinfs) (shen.th* X A V3754 V3755 (freeze (shen.th* Y (cons list (cons A ())) V3754 V3755 V3756)))) (do (shen.unbindv V3601 V3755) Result)))) false))) (do (shen.unbindv V3598 V3755) Result))) false))) (if (shen.pvar? V3597) (let A (shen.newpv V3755) (do (shen.bindv V3597 (cons list (cons A ())) V3755) (let Result (do (shen.incinfs) (shen.th* X A V3754 V3755 (freeze (shen.th* Y (cons list (cons A ())) V3754 V3755 V3756)))) (do (shen.unbindv V3597 V3755) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3603 (shen.lazyderef V3752 V3755) (if (cons? V3603) (let V3604 (shen.lazyderef (hd V3603) V3755) (if (= @p V3604) (let V3605 (shen.lazyderef (tl V3603) V3755) (if (cons? V3605) (let X (hd V3605) (let V3606 (shen.lazyderef (tl V3605) V3755) (if (cons? V3606) (let Y (hd V3606) (let V3607 (shen.lazyderef (tl V3606) V3755) (if (= () V3607) (let V3608 (shen.lazyderef V3753 V3755) (if (cons? V3608) (let A (hd V3608) (let V3609 (shen.lazyderef (tl V3608) V3755) (if (cons? V3609) (let V3610 (shen.lazyderef (hd V3609) V3755) (if (= * V3610) (let V3611 (shen.lazyderef (tl V3609) V3755) (if (cons? V3611) (let B (hd V3611) (let V3612 (shen.lazyderef (tl V3611) V3755) (if (= () V3612) (do (shen.incinfs) (shen.th* X A V3754 V3755 (freeze (shen.th* Y B V3754 V3755 V3756)))) (if (shen.pvar? V3612) (do (shen.bindv V3612 () V3755) (let Result (do (shen.incinfs) (shen.th* X A V3754 V3755 (freeze (shen.th* Y B V3754 V3755 V3756)))) (do (shen.unbindv V3612 V3755) Result))) false)))) (if (shen.pvar? V3611) (let B (shen.newpv V3755) (do (shen.bindv V3611 (cons B ()) V3755) (let Result (do (shen.incinfs) (shen.th* X A V3754 V3755 (freeze (shen.th* Y B V3754 V3755 V3756)))) (do (shen.unbindv V3611 V3755) Result)))) false))) (if (shen.pvar? V3610) (do (shen.bindv V3610 * V3755) (let Result (let V3613 (shen.lazyderef (tl V3609) V3755) (if (cons? V3613) (let B (hd V3613) (let V3614 (shen.lazyderef (tl V3613) V3755) (if (= () V3614) (do (shen.incinfs) (shen.th* X A V3754 V3755 (freeze (shen.th* Y B V3754 V3755 V3756)))) (if (shen.pvar? V3614) (do (shen.bindv V3614 () V3755) (let Result (do (shen.incinfs) (shen.th* X A V3754 V3755 (freeze (shen.th* Y B V3754 V3755 V3756)))) (do (shen.unbindv V3614 V3755) Result))) false)))) (if (shen.pvar? V3613) (let B (shen.newpv V3755) (do (shen.bindv V3613 (cons B ()) V3755) (let Result (do (shen.incinfs) (shen.th* X A V3754 V3755 (freeze (shen.th* Y B V3754 V3755 V3756)))) (do (shen.unbindv V3613 V3755) Result)))) false))) (do (shen.unbindv V3610 V3755) Result))) false))) (if (shen.pvar? V3609) (let B (shen.newpv V3755) (do (shen.bindv V3609 (cons * (cons B ())) V3755) (let Result (do (shen.incinfs) (shen.th* X A V3754 V3755 (freeze (shen.th* Y B V3754 V3755 V3756)))) (do (shen.unbindv V3609 V3755) Result)))) false)))) (if (shen.pvar? V3608) (let A (shen.newpv V3755) (let B (shen.newpv V3755) (do (shen.bindv V3608 (cons A (cons * (cons B ()))) V3755) (let Result (do (shen.incinfs) (shen.th* X A V3754 V3755 (freeze (shen.th* Y B V3754 V3755 V3756)))) (do (shen.unbindv V3608 V3755) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3615 (shen.lazyderef V3752 V3755) (if (cons? V3615) (let V3616 (shen.lazyderef (hd V3615) V3755) (if (= @v V3616) (let V3617 (shen.lazyderef (tl V3615) V3755) (if (cons? V3617) (let X (hd V3617) (let V3618 (shen.lazyderef (tl V3617) V3755) (if (cons? V3618) (let Y (hd V3618) (let V3619 (shen.lazyderef (tl V3618) V3755) (if (= () V3619) (let V3620 (shen.lazyderef V3753 V3755) (if (cons? V3620) (let V3621 (shen.lazyderef (hd V3620) V3755) (if (= vector V3621) (let V3622 (shen.lazyderef (tl V3620) V3755) (if (cons? V3622) (let A (hd V3622) (let V3623 (shen.lazyderef (tl V3622) V3755) (if (= () V3623) (do (shen.incinfs) (shen.th* X A V3754 V3755 (freeze (shen.th* Y (cons vector (cons A ())) V3754 V3755 V3756)))) (if (shen.pvar? V3623) (do (shen.bindv V3623 () V3755) (let Result (do (shen.incinfs) (shen.th* X A V3754 V3755 (freeze (shen.th* Y (cons vector (cons A ())) V3754 V3755 V3756)))) (do (shen.unbindv V3623 V3755) Result))) false)))) (if (shen.pvar? V3622) (let A (shen.newpv V3755) (do (shen.bindv V3622 (cons A ()) V3755) (let Result (do (shen.incinfs) (shen.th* X A V3754 V3755 (freeze (shen.th* Y (cons vector (cons A ())) V3754 V3755 V3756)))) (do (shen.unbindv V3622 V3755) Result)))) false))) (if (shen.pvar? V3621) (do (shen.bindv V3621 vector V3755) (let Result (let V3624 (shen.lazyderef (tl V3620) V3755) (if (cons? V3624) (let A (hd V3624) (let V3625 (shen.lazyderef (tl V3624) V3755) (if (= () V3625) (do (shen.incinfs) (shen.th* X A V3754 V3755 (freeze (shen.th* Y (cons vector (cons A ())) V3754 V3755 V3756)))) (if (shen.pvar? V3625) (do (shen.bindv V3625 () V3755) (let Result (do (shen.incinfs) (shen.th* X A V3754 V3755 (freeze (shen.th* Y (cons vector (cons A ())) V3754 V3755 V3756)))) (do (shen.unbindv V3625 V3755) Result))) false)))) (if (shen.pvar? V3624) (let A (shen.newpv V3755) (do (shen.bindv V3624 (cons A ()) V3755) (let Result (do (shen.incinfs) (shen.th* X A V3754 V3755 (freeze (shen.th* Y (cons vector (cons A ())) V3754 V3755 V3756)))) (do (shen.unbindv V3624 V3755) Result)))) false))) (do (shen.unbindv V3621 V3755) Result))) false))) (if (shen.pvar? V3620) (let A (shen.newpv V3755) (do (shen.bindv V3620 (cons vector (cons A ())) V3755) (let Result (do (shen.incinfs) (shen.th* X A V3754 V3755 (freeze (shen.th* Y (cons vector (cons A ())) V3754 V3755 V3756)))) (do (shen.unbindv V3620 V3755) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3626 (shen.lazyderef V3752 V3755) (if (cons? V3626) (let V3627 (shen.lazyderef (hd V3626) V3755) (if (= @s V3627) (let V3628 (shen.lazyderef (tl V3626) V3755) (if (cons? V3628) (let X (hd V3628) (let V3629 (shen.lazyderef (tl V3628) V3755) (if (cons? V3629) (let Y (hd V3629) (let V3630 (shen.lazyderef (tl V3629) V3755) (if (= () V3630) (let V3631 (shen.lazyderef V3753 V3755) (if (= string V3631) (do (shen.incinfs) (shen.th* X string V3754 V3755 (freeze (shen.th* Y string V3754 V3755 V3756)))) (if (shen.pvar? V3631) (do (shen.bindv V3631 string V3755) (let Result (do (shen.incinfs) (shen.th* X string V3754 V3755 (freeze (shen.th* Y string V3754 V3755 V3756)))) (do (shen.unbindv V3631 V3755) Result))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3632 (shen.lazyderef V3752 V3755) (if (cons? V3632) (let V3633 (shen.lazyderef (hd V3632) V3755) (if (= lambda V3633) (let V3634 (shen.lazyderef (tl V3632) V3755) (if (cons? V3634) (let X (hd V3634) (let V3635 (shen.lazyderef (tl V3634) V3755) (if (cons? V3635) (let Y (hd V3635) (let V3636 (shen.lazyderef (tl V3635) V3755) (if (= () V3636) (let V3637 (shen.lazyderef V3753 V3755) (if (cons? V3637) (let A (hd V3637) (let V3638 (shen.lazyderef (tl V3637) V3755) (if (cons? V3638) (let V3639 (shen.lazyderef (hd V3638) V3755) (if (= --> V3639) (let V3640 (shen.lazyderef (tl V3638) V3755) (if (cons? V3640) (let B (hd V3640) (let V3641 (shen.lazyderef (tl V3640) V3755) (if (= () V3641) (let Z (shen.newpv V3755) (let X&& (shen.newpv V3755) (do (shen.incinfs) (cut Throwcontrol V3755 (freeze (bind X&& (shen.placeholder) V3755 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3755) (shen.lazyderef X V3755) (shen.lazyderef Y V3755)) V3755 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3754) V3755 V3756)))))))))) (if (shen.pvar? V3641) (do (shen.bindv V3641 () V3755) (let Result (let Z (shen.newpv V3755) (let X&& (shen.newpv V3755) (do (shen.incinfs) (cut Throwcontrol V3755 (freeze (bind X&& (shen.placeholder) V3755 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3755) (shen.lazyderef X V3755) (shen.lazyderef Y V3755)) V3755 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3754) V3755 V3756)))))))))) (do (shen.unbindv V3641 V3755) Result))) false)))) (if (shen.pvar? V3640) (let B (shen.newpv V3755) (do (shen.bindv V3640 (cons B ()) V3755) (let Result (let Z (shen.newpv V3755) (let X&& (shen.newpv V3755) (do (shen.incinfs) (cut Throwcontrol V3755 (freeze (bind X&& (shen.placeholder) V3755 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3755) (shen.lazyderef X V3755) (shen.lazyderef Y V3755)) V3755 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3754) V3755 V3756)))))))))) (do (shen.unbindv V3640 V3755) Result)))) false))) (if (shen.pvar? V3639) (do (shen.bindv V3639 --> V3755) (let Result (let V3642 (shen.lazyderef (tl V3638) V3755) (if (cons? V3642) (let B (hd V3642) (let V3643 (shen.lazyderef (tl V3642) V3755) (if (= () V3643) (let Z (shen.newpv V3755) (let X&& (shen.newpv V3755) (do (shen.incinfs) (cut Throwcontrol V3755 (freeze (bind X&& (shen.placeholder) V3755 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3755) (shen.lazyderef X V3755) (shen.lazyderef Y V3755)) V3755 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3754) V3755 V3756)))))))))) (if (shen.pvar? V3643) (do (shen.bindv V3643 () V3755) (let Result (let Z (shen.newpv V3755) (let X&& (shen.newpv V3755) (do (shen.incinfs) (cut Throwcontrol V3755 (freeze (bind X&& (shen.placeholder) V3755 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3755) (shen.lazyderef X V3755) (shen.lazyderef Y V3755)) V3755 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3754) V3755 V3756)))))))))) (do (shen.unbindv V3643 V3755) Result))) false)))) (if (shen.pvar? V3642) (let B (shen.newpv V3755) (do (shen.bindv V3642 (cons B ()) V3755) (let Result (let Z (shen.newpv V3755) (let X&& (shen.newpv V3755) (do (shen.incinfs) (cut Throwcontrol V3755 (freeze (bind X&& (shen.placeholder) V3755 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3755) (shen.lazyderef X V3755) (shen.lazyderef Y V3755)) V3755 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3754) V3755 V3756)))))))))) (do (shen.unbindv V3642 V3755) Result)))) false))) (do (shen.unbindv V3639 V3755) Result))) false))) (if (shen.pvar? V3638) (let B (shen.newpv V3755) (do (shen.bindv V3638 (cons --> (cons B ())) V3755) (let Result (let Z (shen.newpv V3755) (let X&& (shen.newpv V3755) (do (shen.incinfs) (cut Throwcontrol V3755 (freeze (bind X&& (shen.placeholder) V3755 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3755) (shen.lazyderef X V3755) (shen.lazyderef Y V3755)) V3755 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3754) V3755 V3756)))))))))) (do (shen.unbindv V3638 V3755) Result)))) false)))) (if (shen.pvar? V3637) (let A (shen.newpv V3755) (let B (shen.newpv V3755) (do (shen.bindv V3637 (cons A (cons --> (cons B ()))) V3755) (let Result (let Z (shen.newpv V3755) (let X&& (shen.newpv V3755) (do (shen.incinfs) (cut Throwcontrol V3755 (freeze (bind X&& (shen.placeholder) V3755 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3755) (shen.lazyderef X V3755) (shen.lazyderef Y V3755)) V3755 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3754) V3755 V3756)))))))))) (do (shen.unbindv V3637 V3755) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3644 (shen.lazyderef V3752 V3755) (if (cons? V3644) (let V3645 (shen.lazyderef (hd V3644) V3755) (if (= let V3645) (let V3646 (shen.lazyderef (tl V3644) V3755) (if (cons? V3646) (let X (hd V3646) (let V3647 (shen.lazyderef (tl V3646) V3755) (if (cons? V3647) (let Y (hd V3647) (let V3648 (shen.lazyderef (tl V3647) V3755) (if (cons? V3648) (let Z (hd V3648) (let V3649 (shen.lazyderef (tl V3648) V3755) (if (= () V3649) (let W (shen.newpv V3755) (let X&& (shen.newpv V3755) (let B (shen.newpv V3755) (do (shen.incinfs) (shen.th* Y B V3754 V3755 (freeze (bind X&& (shen.placeholder) V3755 (freeze (bind W (shen.ebr (shen.lazyderef X&& V3755) (shen.lazyderef X V3755) (shen.lazyderef Z V3755)) V3755 (freeze (shen.th* W V3753 (cons (cons X&& (cons : (cons B ()))) V3754) V3755 V3756))))))))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3650 (shen.lazyderef V3752 V3755) (if (cons? V3650) (let V3651 (shen.lazyderef (hd V3650) V3755) (if (= open V3651) (let V3652 (shen.lazyderef (tl V3650) V3755) (if (cons? V3652) (let FileName (hd V3652) (let V3653 (shen.lazyderef (tl V3652) V3755) (if (cons? V3653) (let Direction3583 (hd V3653) (let V3654 (shen.lazyderef (tl V3653) V3755) (if (= () V3654) (let V3655 (shen.lazyderef V3753 V3755) (if (cons? V3655) (let V3656 (shen.lazyderef (hd V3655) V3755) (if (= stream V3656) (let V3657 (shen.lazyderef (tl V3655) V3755) (if (cons? V3657) (let Direction (hd V3657) (let V3658 (shen.lazyderef (tl V3657) V3755) (if (= () V3658) (do (shen.incinfs) (unify! Direction Direction3583 V3755 (freeze (cut Throwcontrol V3755 (freeze (fwhen (element? (shen.lazyderef Direction V3755) (cons in (cons out ()))) V3755 (freeze (shen.th* FileName string V3754 V3755 V3756)))))))) (if (shen.pvar? V3658) (do (shen.bindv V3658 () V3755) (let Result (do (shen.incinfs) (unify! Direction Direction3583 V3755 (freeze (cut Throwcontrol V3755 (freeze (fwhen (element? (shen.lazyderef Direction V3755) (cons in (cons out ()))) V3755 (freeze (shen.th* FileName string V3754 V3755 V3756)))))))) (do (shen.unbindv V3658 V3755) Result))) false)))) (if (shen.pvar? V3657) (let Direction (shen.newpv V3755) (do (shen.bindv V3657 (cons Direction ()) V3755) (let Result (do (shen.incinfs) (unify! Direction Direction3583 V3755 (freeze (cut Throwcontrol V3755 (freeze (fwhen (element? (shen.lazyderef Direction V3755) (cons in (cons out ()))) V3755 (freeze (shen.th* FileName string V3754 V3755 V3756)))))))) (do (shen.unbindv V3657 V3755) Result)))) false))) (if (shen.pvar? V3656) (do (shen.bindv V3656 stream V3755) (let Result (let V3659 (shen.lazyderef (tl V3655) V3755) (if (cons? V3659) (let Direction (hd V3659) (let V3660 (shen.lazyderef (tl V3659) V3755) (if (= () V3660) (do (shen.incinfs) (unify! Direction Direction3583 V3755 (freeze (cut Throwcontrol V3755 (freeze (fwhen (element? (shen.lazyderef Direction V3755) (cons in (cons out ()))) V3755 (freeze (shen.th* FileName string V3754 V3755 V3756)))))))) (if (shen.pvar? V3660) (do (shen.bindv V3660 () V3755) (let Result (do (shen.incinfs) (unify! Direction Direction3583 V3755 (freeze (cut Throwcontrol V3755 (freeze (fwhen (element? (shen.lazyderef Direction V3755) (cons in (cons out ()))) V3755 (freeze (shen.th* FileName string V3754 V3755 V3756)))))))) (do (shen.unbindv V3660 V3755) Result))) false)))) (if (shen.pvar? V3659) (let Direction (shen.newpv V3755) (do (shen.bindv V3659 (cons Direction ()) V3755) (let Result (do (shen.incinfs) (unify! Direction Direction3583 V3755 (freeze (cut Throwcontrol V3755 (freeze (fwhen (element? (shen.lazyderef Direction V3755) (cons in (cons out ()))) V3755 (freeze (shen.th* FileName string V3754 V3755 V3756)))))))) (do (shen.unbindv V3659 V3755) Result)))) false))) (do (shen.unbindv V3656 V3755) Result))) false))) (if (shen.pvar? V3655) (let Direction (shen.newpv V3755) (do (shen.bindv V3655 (cons stream (cons Direction ())) V3755) (let Result (do (shen.incinfs) (unify! Direction Direction3583 V3755 (freeze (cut Throwcontrol V3755 (freeze (fwhen (element? (shen.lazyderef Direction V3755) (cons in (cons out ()))) V3755 (freeze (shen.th* FileName string V3754 V3755 V3756)))))))) (do (shen.unbindv V3655 V3755) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3661 (shen.lazyderef V3752 V3755) (if (cons? V3661) (let V3662 (shen.lazyderef (hd V3661) V3755) (if (= type V3662) (let V3663 (shen.lazyderef (tl V3661) V3755) (if (cons? V3663) (let X (hd V3663) (let V3664 (shen.lazyderef (tl V3663) V3755) (if (cons? V3664) (let A (hd V3664) (let V3665 (shen.lazyderef (tl V3664) V3755) (if (= () V3665) (do (shen.incinfs) (cut Throwcontrol V3755 (freeze (unify A V3753 V3755 (freeze (shen.th* X A V3754 V3755 V3756)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3666 (shen.lazyderef V3752 V3755) (if (cons? V3666) (let V3667 (shen.lazyderef (hd V3666) V3755) (if (= input+ V3667) (let V3668 (shen.lazyderef (tl V3666) V3755) (if (cons? V3668) (let A (hd V3668) (let V3669 (shen.lazyderef (tl V3668) V3755) (if (cons? V3669) (let Stream (hd V3669) (let V3670 (shen.lazyderef (tl V3669) V3755) (if (= () V3670) (let C (shen.newpv V3755) (do (shen.incinfs) (bind C (shen.demodulate (shen.lazyderef A V3755)) V3755 (freeze (unify V3753 C V3755 (freeze (shen.th* Stream (cons stream (cons in ())) V3754 V3755 V3756))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3671 (shen.lazyderef V3752 V3755) (if (cons? V3671) (let V3672 (shen.lazyderef (hd V3671) V3755) (if (= set V3672) (let V3673 (shen.lazyderef (tl V3671) V3755) (if (cons? V3673) (let Var (hd V3673) (let V3674 (shen.lazyderef (tl V3673) V3755) (if (cons? V3674) (let Val (hd V3674) (let V3675 (shen.lazyderef (tl V3674) V3755) (if (= () V3675) (do (shen.incinfs) (cut Throwcontrol V3755 (freeze (shen.th* Var symbol V3754 V3755 (freeze (cut Throwcontrol V3755 (freeze (shen.th* (cons value (cons Var ())) V3753 V3754 V3755 (freeze (shen.th* Val V3753 V3754 V3755 V3756)))))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let NewHyp (shen.newpv V3755) (do (shen.incinfs) (shen.t*-hyps V3754 NewHyp V3755 (freeze (shen.th* V3752 V3753 NewHyp V3755 V3756))))) (if (= Case false) (let Case (let V3676 (shen.lazyderef V3752 V3755) (if (cons? V3676) (let V3677 (shen.lazyderef (hd V3676) V3755) (if (= define V3677) (let V3678 (shen.lazyderef (tl V3676) V3755) (if (cons? V3678) (let F (hd V3678) (let X (tl V3678) (do (shen.incinfs) (cut Throwcontrol V3755 (freeze (shen.t*-def (cons define (cons F X)) V3753 V3754 V3755 V3756)))))) false)) false)) false)) (if (= Case false) (let Case (let V3679 (shen.lazyderef V3752 V3755) (if (cons? V3679) (let V3680 (shen.lazyderef (hd V3679) V3755) (if (= defmacro V3680) (let V3681 (shen.lazyderef V3753 V3755) (if (= unit V3681) (do (shen.incinfs) (cut Throwcontrol V3755 V3756)) (if (shen.pvar? V3681) (do (shen.bindv V3681 unit V3755) (let Result (do (shen.incinfs) (cut Throwcontrol V3755 V3756)) (do (shen.unbindv V3681 V3755) Result))) false))) false)) false)) (if (= Case false) (let Case (let V3682 (shen.lazyderef V3752 V3755) (if (cons? V3682) (let V3683 (shen.lazyderef (hd V3682) V3755) (if (= shen.process-datatype V3683) (let V3684 (shen.lazyderef V3753 V3755) (if (= symbol V3684) (do (shen.incinfs) (thaw V3756)) (if (shen.pvar? V3684) (do (shen.bindv V3684 symbol V3755) (let Result (do (shen.incinfs) (thaw V3756)) (do (shen.unbindv V3684 V3755) Result))) false))) false)) false)) (if (= Case false) (let Case (let V3685 (shen.lazyderef V3752 V3755) (if (cons? V3685) (let V3686 (shen.lazyderef (hd V3685) V3755) (if (= shen.synonyms-help V3686) (let V3687 (shen.lazyderef V3753 V3755) (if (= symbol V3687) (do (shen.incinfs) (thaw V3756)) (if (shen.pvar? V3687) (do (shen.bindv V3687 symbol V3755) (let Result (do (shen.incinfs) (thaw V3756)) (do (shen.unbindv V3687 V3755) Result))) false))) false)) false)) (if (= Case false) (let Datatypes (shen.newpv V3755) (do (shen.incinfs) (bind Datatypes (value shen.*datatypes*) V3755 (freeze (shen.udefs* (cons V3752 (cons : (cons V3753 ()))) V3754 Datatypes V3755 V3756))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)))))

(defun shen.t*-hyps (V3761 V3762 V3763 V3764) (let Case (let V3498 (shen.lazyderef V3761 V3763) (if (cons? V3498) (let V3499 (shen.lazyderef (hd V3498) V3763) (if (cons? V3499) (let V3500 (shen.lazyderef (hd V3499) V3763) (if (cons? V3500) (let V3501 (shen.lazyderef (hd V3500) V3763) (if (= cons V3501) (let V3502 (shen.lazyderef (tl V3500) V3763) (if (cons? V3502) (let X (hd V3502) (let V3503 (shen.lazyderef (tl V3502) V3763) (if (cons? V3503) (let Y (hd V3503) (let V3504 (shen.lazyderef (tl V3503) V3763) (if (= () V3504) (let V3505 (shen.lazyderef (tl V3499) V3763) (if (cons? V3505) (let V3506 (shen.lazyderef (hd V3505) V3763) (if (= : V3506) (let V3507 (shen.lazyderef (tl V3505) V3763) (if (cons? V3507) (let V3508 (shen.lazyderef (hd V3507) V3763) (if (cons? V3508) (let V3509 (shen.lazyderef (hd V3508) V3763) (if (= list V3509) (let V3510 (shen.lazyderef (tl V3508) V3763) (if (cons? V3510) (let A (hd V3510) (let V3511 (shen.lazyderef (tl V3510) V3763) (if (= () V3511) (let V3512 (shen.lazyderef (tl V3507) V3763) (if (= () V3512) (let Hyp (tl V3498) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (cons list (cons (shen.lazyderef A V3763) ())) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (if (shen.pvar? V3512) (do (shen.bindv V3512 () V3763) (let Result (let Hyp (tl V3498) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (cons list (cons (shen.lazyderef A V3763) ())) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (do (shen.unbindv V3512 V3763) Result))) false))) (if (shen.pvar? V3511) (do (shen.bindv V3511 () V3763) (let Result (let V3513 (shen.lazyderef (tl V3507) V3763) (if (= () V3513) (let Hyp (tl V3498) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (cons list (cons (shen.lazyderef A V3763) ())) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (if (shen.pvar? V3513) (do (shen.bindv V3513 () V3763) (let Result (let Hyp (tl V3498) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (cons list (cons (shen.lazyderef A V3763) ())) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (do (shen.unbindv V3513 V3763) Result))) false))) (do (shen.unbindv V3511 V3763) Result))) false)))) (if (shen.pvar? V3510) (let A (shen.newpv V3763) (do (shen.bindv V3510 (cons A ()) V3763) (let Result (let V3514 (shen.lazyderef (tl V3507) V3763) (if (= () V3514) (let Hyp (tl V3498) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (cons list (cons (shen.lazyderef A V3763) ())) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (if (shen.pvar? V3514) (do (shen.bindv V3514 () V3763) (let Result (let Hyp (tl V3498) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (cons list (cons (shen.lazyderef A V3763) ())) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (do (shen.unbindv V3514 V3763) Result))) false))) (do (shen.unbindv V3510 V3763) Result)))) false))) (if (shen.pvar? V3509) (do (shen.bindv V3509 list V3763) (let Result (let V3515 (shen.lazyderef (tl V3508) V3763) (if (cons? V3515) (let A (hd V3515) (let V3516 (shen.lazyderef (tl V3515) V3763) (if (= () V3516) (let V3517 (shen.lazyderef (tl V3507) V3763) (if (= () V3517) (let Hyp (tl V3498) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (cons list (cons (shen.lazyderef A V3763) ())) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (if (shen.pvar? V3517) (do (shen.bindv V3517 () V3763) (let Result (let Hyp (tl V3498) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (cons list (cons (shen.lazyderef A V3763) ())) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (do (shen.unbindv V3517 V3763) Result))) false))) (if (shen.pvar? V3516) (do (shen.bindv V3516 () V3763) (let Result (let V3518 (shen.lazyderef (tl V3507) V3763) (if (= () V3518) (let Hyp (tl V3498) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (cons list (cons (shen.lazyderef A V3763) ())) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (if (shen.pvar? V3518) (do (shen.bindv V3518 () V3763) (let Result (let Hyp (tl V3498) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (cons list (cons (shen.lazyderef A V3763) ())) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (do (shen.unbindv V3518 V3763) Result))) false))) (do (shen.unbindv V3516 V3763) Result))) false)))) (if (shen.pvar? V3515) (let A (shen.newpv V3763) (do (shen.bindv V3515 (cons A ()) V3763) (let Result (let V3519 (shen.lazyderef (tl V3507) V3763) (if (= () V3519) (let Hyp (tl V3498) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (cons list (cons (shen.lazyderef A V3763) ())) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (if (shen.pvar? V3519) (do (shen.bindv V3519 () V3763) (let Result (let Hyp (tl V3498) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (cons list (cons (shen.lazyderef A V3763) ())) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (do (shen.unbindv V3519 V3763) Result))) false))) (do (shen.unbindv V3515 V3763) Result)))) false))) (do (shen.unbindv V3509 V3763) Result))) false))) (if (shen.pvar? V3508) (let A (shen.newpv V3763) (do (shen.bindv V3508 (cons list (cons A ())) V3763) (let Result (let V3520 (shen.lazyderef (tl V3507) V3763) (if (= () V3520) (let Hyp (tl V3498) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (cons list (cons (shen.lazyderef A V3763) ())) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (if (shen.pvar? V3520) (do (shen.bindv V3520 () V3763) (let Result (let Hyp (tl V3498) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (cons list (cons (shen.lazyderef A V3763) ())) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (do (shen.unbindv V3520 V3763) Result))) false))) (do (shen.unbindv V3508 V3763) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3521 (shen.lazyderef V3761 V3763) (if (cons? V3521) (let V3522 (shen.lazyderef (hd V3521) V3763) (if (cons? V3522) (let V3523 (shen.lazyderef (hd V3522) V3763) (if (cons? V3523) (let V3524 (shen.lazyderef (hd V3523) V3763) (if (= @p V3524) (let V3525 (shen.lazyderef (tl V3523) V3763) (if (cons? V3525) (let X (hd V3525) (let V3526 (shen.lazyderef (tl V3525) V3763) (if (cons? V3526) (let Y (hd V3526) (let V3527 (shen.lazyderef (tl V3526) V3763) (if (= () V3527) (let V3528 (shen.lazyderef (tl V3522) V3763) (if (cons? V3528) (let V3529 (shen.lazyderef (hd V3528) V3763) (if (= : V3529) (let V3530 (shen.lazyderef (tl V3528) V3763) (if (cons? V3530) (let V3531 (shen.lazyderef (hd V3530) V3763) (if (cons? V3531) (let A (hd V3531) (let V3532 (shen.lazyderef (tl V3531) V3763) (if (cons? V3532) (let V3533 (shen.lazyderef (hd V3532) V3763) (if (= * V3533) (let V3534 (shen.lazyderef (tl V3532) V3763) (if (cons? V3534) (let B (hd V3534) (let V3535 (shen.lazyderef (tl V3534) V3763) (if (= () V3535) (let V3536 (shen.lazyderef (tl V3530) V3763) (if (= () V3536) (let Hyp (tl V3521) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (shen.lazyderef B V3763) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (if (shen.pvar? V3536) (do (shen.bindv V3536 () V3763) (let Result (let Hyp (tl V3521) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (shen.lazyderef B V3763) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (do (shen.unbindv V3536 V3763) Result))) false))) (if (shen.pvar? V3535) (do (shen.bindv V3535 () V3763) (let Result (let V3537 (shen.lazyderef (tl V3530) V3763) (if (= () V3537) (let Hyp (tl V3521) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (shen.lazyderef B V3763) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (if (shen.pvar? V3537) (do (shen.bindv V3537 () V3763) (let Result (let Hyp (tl V3521) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (shen.lazyderef B V3763) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (do (shen.unbindv V3537 V3763) Result))) false))) (do (shen.unbindv V3535 V3763) Result))) false)))) (if (shen.pvar? V3534) (let B (shen.newpv V3763) (do (shen.bindv V3534 (cons B ()) V3763) (let Result (let V3538 (shen.lazyderef (tl V3530) V3763) (if (= () V3538) (let Hyp (tl V3521) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (shen.lazyderef B V3763) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (if (shen.pvar? V3538) (do (shen.bindv V3538 () V3763) (let Result (let Hyp (tl V3521) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (shen.lazyderef B V3763) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (do (shen.unbindv V3538 V3763) Result))) false))) (do (shen.unbindv V3534 V3763) Result)))) false))) (if (shen.pvar? V3533) (do (shen.bindv V3533 * V3763) (let Result (let V3539 (shen.lazyderef (tl V3532) V3763) (if (cons? V3539) (let B (hd V3539) (let V3540 (shen.lazyderef (tl V3539) V3763) (if (= () V3540) (let V3541 (shen.lazyderef (tl V3530) V3763) (if (= () V3541) (let Hyp (tl V3521) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (shen.lazyderef B V3763) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (if (shen.pvar? V3541) (do (shen.bindv V3541 () V3763) (let Result (let Hyp (tl V3521) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (shen.lazyderef B V3763) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (do (shen.unbindv V3541 V3763) Result))) false))) (if (shen.pvar? V3540) (do (shen.bindv V3540 () V3763) (let Result (let V3542 (shen.lazyderef (tl V3530) V3763) (if (= () V3542) (let Hyp (tl V3521) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (shen.lazyderef B V3763) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (if (shen.pvar? V3542) (do (shen.bindv V3542 () V3763) (let Result (let Hyp (tl V3521) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (shen.lazyderef B V3763) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (do (shen.unbindv V3542 V3763) Result))) false))) (do (shen.unbindv V3540 V3763) Result))) false)))) (if (shen.pvar? V3539) (let B (shen.newpv V3763) (do (shen.bindv V3539 (cons B ()) V3763) (let Result (let V3543 (shen.lazyderef (tl V3530) V3763) (if (= () V3543) (let Hyp (tl V3521) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (shen.lazyderef B V3763) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (if (shen.pvar? V3543) (do (shen.bindv V3543 () V3763) (let Result (let Hyp (tl V3521) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (shen.lazyderef B V3763) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (do (shen.unbindv V3543 V3763) Result))) false))) (do (shen.unbindv V3539 V3763) Result)))) false))) (do (shen.unbindv V3533 V3763) Result))) false))) (if (shen.pvar? V3532) (let B (shen.newpv V3763) (do (shen.bindv V3532 (cons * (cons B ())) V3763) (let Result (let V3544 (shen.lazyderef (tl V3530) V3763) (if (= () V3544) (let Hyp (tl V3521) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (shen.lazyderef B V3763) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (if (shen.pvar? V3544) (do (shen.bindv V3544 () V3763) (let Result (let Hyp (tl V3521) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (shen.lazyderef B V3763) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (do (shen.unbindv V3544 V3763) Result))) false))) (do (shen.unbindv V3532 V3763) Result)))) false)))) (if (shen.pvar? V3531) (let A (shen.newpv V3763) (let B (shen.newpv V3763) (do (shen.bindv V3531 (cons A (cons * (cons B ()))) V3763) (let Result (let V3545 (shen.lazyderef (tl V3530) V3763) (if (= () V3545) (let Hyp (tl V3521) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (shen.lazyderef B V3763) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (if (shen.pvar? V3545) (do (shen.bindv V3545 () V3763) (let Result (let Hyp (tl V3521) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (shen.lazyderef B V3763) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (do (shen.unbindv V3545 V3763) Result))) false))) (do (shen.unbindv V3531 V3763) Result))))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3546 (shen.lazyderef V3761 V3763) (if (cons? V3546) (let V3547 (shen.lazyderef (hd V3546) V3763) (if (cons? V3547) (let V3548 (shen.lazyderef (hd V3547) V3763) (if (cons? V3548) (let V3549 (shen.lazyderef (hd V3548) V3763) (if (= @v V3549) (let V3550 (shen.lazyderef (tl V3548) V3763) (if (cons? V3550) (let X (hd V3550) (let V3551 (shen.lazyderef (tl V3550) V3763) (if (cons? V3551) (let Y (hd V3551) (let V3552 (shen.lazyderef (tl V3551) V3763) (if (= () V3552) (let V3553 (shen.lazyderef (tl V3547) V3763) (if (cons? V3553) (let V3554 (shen.lazyderef (hd V3553) V3763) (if (= : V3554) (let V3555 (shen.lazyderef (tl V3553) V3763) (if (cons? V3555) (let V3556 (shen.lazyderef (hd V3555) V3763) (if (cons? V3556) (let V3557 (shen.lazyderef (hd V3556) V3763) (if (= vector V3557) (let V3558 (shen.lazyderef (tl V3556) V3763) (if (cons? V3558) (let A (hd V3558) (let V3559 (shen.lazyderef (tl V3558) V3763) (if (= () V3559) (let V3560 (shen.lazyderef (tl V3555) V3763) (if (= () V3560) (let Hyp (tl V3546) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (cons vector (cons (shen.lazyderef A V3763) ())) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (if (shen.pvar? V3560) (do (shen.bindv V3560 () V3763) (let Result (let Hyp (tl V3546) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (cons vector (cons (shen.lazyderef A V3763) ())) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (do (shen.unbindv V3560 V3763) Result))) false))) (if (shen.pvar? V3559) (do (shen.bindv V3559 () V3763) (let Result (let V3561 (shen.lazyderef (tl V3555) V3763) (if (= () V3561) (let Hyp (tl V3546) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (cons vector (cons (shen.lazyderef A V3763) ())) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (if (shen.pvar? V3561) (do (shen.bindv V3561 () V3763) (let Result (let Hyp (tl V3546) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (cons vector (cons (shen.lazyderef A V3763) ())) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (do (shen.unbindv V3561 V3763) Result))) false))) (do (shen.unbindv V3559 V3763) Result))) false)))) (if (shen.pvar? V3558) (let A (shen.newpv V3763) (do (shen.bindv V3558 (cons A ()) V3763) (let Result (let V3562 (shen.lazyderef (tl V3555) V3763) (if (= () V3562) (let Hyp (tl V3546) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (cons vector (cons (shen.lazyderef A V3763) ())) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (if (shen.pvar? V3562) (do (shen.bindv V3562 () V3763) (let Result (let Hyp (tl V3546) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (cons vector (cons (shen.lazyderef A V3763) ())) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (do (shen.unbindv V3562 V3763) Result))) false))) (do (shen.unbindv V3558 V3763) Result)))) false))) (if (shen.pvar? V3557) (do (shen.bindv V3557 vector V3763) (let Result (let V3563 (shen.lazyderef (tl V3556) V3763) (if (cons? V3563) (let A (hd V3563) (let V3564 (shen.lazyderef (tl V3563) V3763) (if (= () V3564) (let V3565 (shen.lazyderef (tl V3555) V3763) (if (= () V3565) (let Hyp (tl V3546) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (cons vector (cons (shen.lazyderef A V3763) ())) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (if (shen.pvar? V3565) (do (shen.bindv V3565 () V3763) (let Result (let Hyp (tl V3546) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (cons vector (cons (shen.lazyderef A V3763) ())) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (do (shen.unbindv V3565 V3763) Result))) false))) (if (shen.pvar? V3564) (do (shen.bindv V3564 () V3763) (let Result (let V3566 (shen.lazyderef (tl V3555) V3763) (if (= () V3566) (let Hyp (tl V3546) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (cons vector (cons (shen.lazyderef A V3763) ())) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (if (shen.pvar? V3566) (do (shen.bindv V3566 () V3763) (let Result (let Hyp (tl V3546) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (cons vector (cons (shen.lazyderef A V3763) ())) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (do (shen.unbindv V3566 V3763) Result))) false))) (do (shen.unbindv V3564 V3763) Result))) false)))) (if (shen.pvar? V3563) (let A (shen.newpv V3763) (do (shen.bindv V3563 (cons A ()) V3763) (let Result (let V3567 (shen.lazyderef (tl V3555) V3763) (if (= () V3567) (let Hyp (tl V3546) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (cons vector (cons (shen.lazyderef A V3763) ())) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (if (shen.pvar? V3567) (do (shen.bindv V3567 () V3763) (let Result (let Hyp (tl V3546) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (cons vector (cons (shen.lazyderef A V3763) ())) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (do (shen.unbindv V3567 V3763) Result))) false))) (do (shen.unbindv V3563 V3763) Result)))) false))) (do (shen.unbindv V3557 V3763) Result))) false))) (if (shen.pvar? V3556) (let A (shen.newpv V3763) (do (shen.bindv V3556 (cons vector (cons A ())) V3763) (let Result (let V3568 (shen.lazyderef (tl V3555) V3763) (if (= () V3568) (let Hyp (tl V3546) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (cons vector (cons (shen.lazyderef A V3763) ())) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (if (shen.pvar? V3568) (do (shen.bindv V3568 () V3763) (let Result (let Hyp (tl V3546) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons (shen.lazyderef A V3763) ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons (cons vector (cons (shen.lazyderef A V3763) ())) ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (do (shen.unbindv V3568 V3763) Result))) false))) (do (shen.unbindv V3556 V3763) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3569 (shen.lazyderef V3761 V3763) (if (cons? V3569) (let V3570 (shen.lazyderef (hd V3569) V3763) (if (cons? V3570) (let V3571 (shen.lazyderef (hd V3570) V3763) (if (cons? V3571) (let V3572 (shen.lazyderef (hd V3571) V3763) (if (= @s V3572) (let V3573 (shen.lazyderef (tl V3571) V3763) (if (cons? V3573) (let X (hd V3573) (let V3574 (shen.lazyderef (tl V3573) V3763) (if (cons? V3574) (let Y (hd V3574) (let V3575 (shen.lazyderef (tl V3574) V3763) (if (= () V3575) (let V3576 (shen.lazyderef (tl V3570) V3763) (if (cons? V3576) (let V3577 (shen.lazyderef (hd V3576) V3763) (if (= : V3577) (let V3578 (shen.lazyderef (tl V3576) V3763) (if (cons? V3578) (let V3579 (shen.lazyderef (hd V3578) V3763) (if (= string V3579) (let V3580 (shen.lazyderef (tl V3578) V3763) (if (= () V3580) (let Hyp (tl V3569) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons string ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (if (shen.pvar? V3580) (do (shen.bindv V3580 () V3763) (let Result (let Hyp (tl V3569) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons string ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (do (shen.unbindv V3580 V3763) Result))) false))) (if (shen.pvar? V3579) (do (shen.bindv V3579 string V3763) (let Result (let V3581 (shen.lazyderef (tl V3578) V3763) (if (= () V3581) (let Hyp (tl V3569) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons string ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (if (shen.pvar? V3581) (do (shen.bindv V3581 () V3763) (let Result (let Hyp (tl V3569) (do (shen.incinfs) (bind V3762 (cons (cons (shen.lazyderef X V3763) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3763) (cons : (cons string ()))) (shen.lazyderef Hyp V3763))) V3763 V3764))) (do (shen.unbindv V3581 V3763) Result))) false))) (do (shen.unbindv V3579 V3763) Result))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let V3582 (shen.lazyderef V3761 V3763) (if (cons? V3582) (let X (hd V3582) (let Hyp (tl V3582) (let NewHyps (shen.newpv V3763) (do (shen.incinfs) (bind V3762 (cons (shen.lazyderef X V3763) (shen.lazyderef NewHyps V3763)) V3763 (freeze (shen.t*-hyps Hyp NewHyps V3763 V3764))))))) false)) Case)) Case)) Case)) Case)))

(defun shen.show (V3781 V3782 V3783 V3784) (cond ((value shen.*spy*) (do (shen.line) (do (shen.show-p (shen.deref V3781 V3783)) (do (nl 1) (do (nl 1) (do (shen.show-assumptions (shen.deref V3782 V3783) 1) (do (shen.prhush "
> " (stoutput)) (do (shen.pause-for-user) (thaw V3784))))))))) (true (thaw V3784))))

(defun shen.line () (let Infs (inferences) (shen.prhush (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V3786) (cond ((and (cons? V3786) (and (cons? (tl V3786)) (and (= : (hd (tl V3786))) (and (cons? (tl (tl V3786))) (= () (tl (tl (tl V3786)))))))) (shen.prhush (shen.app (hd V3786) (cn " : " (shen.app (hd (tl (tl V3786))) "" shen.r)) shen.r) (stoutput))) (true (shen.prhush (shen.app V3786 "" shen.r) (stoutput)))))

(defun shen.show-assumptions (V3791 V3792) (cond ((= () V3791) shen.skip) ((cons? V3791) (do (shen.prhush (shen.app V3792 ". " shen.a) (stoutput)) (do (shen.show-p (hd V3791)) (do (nl 1) (shen.show-assumptions (tl V3791) (+ V3792 1)))))) (true (shen.f_error shen.show-assumptions))))

(defun shen.pause-for-user () (let Byte (read-byte (stinput)) (if (= Byte 94) (simple-error "input aborted
") (nl 1))))

(defun shen.typedf? (V3794) (cons? (assoc V3794 (value shen.*signedfuncs*))))

(defun shen.sigf (V3796) (concat shen.type-signature-of- V3796))

(defun shen.placeholder () (gensym &&))

(defun shen.base (V3801 V3802 V3803 V3804) (let Case (let V3485 (shen.lazyderef V3802 V3803) (if (= number V3485) (do (shen.incinfs) (fwhen (number? (shen.lazyderef V3801 V3803)) V3803 V3804)) (if (shen.pvar? V3485) (do (shen.bindv V3485 number V3803) (let Result (do (shen.incinfs) (fwhen (number? (shen.lazyderef V3801 V3803)) V3803 V3804)) (do (shen.unbindv V3485 V3803) Result))) false))) (if (= Case false) (let Case (let V3486 (shen.lazyderef V3802 V3803) (if (= boolean V3486) (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V3801 V3803)) V3803 V3804)) (if (shen.pvar? V3486) (do (shen.bindv V3486 boolean V3803) (let Result (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V3801 V3803)) V3803 V3804)) (do (shen.unbindv V3486 V3803) Result))) false))) (if (= Case false) (let Case (let V3487 (shen.lazyderef V3802 V3803) (if (= string V3487) (do (shen.incinfs) (fwhen (string? (shen.lazyderef V3801 V3803)) V3803 V3804)) (if (shen.pvar? V3487) (do (shen.bindv V3487 string V3803) (let Result (do (shen.incinfs) (fwhen (string? (shen.lazyderef V3801 V3803)) V3803 V3804)) (do (shen.unbindv V3487 V3803) Result))) false))) (if (= Case false) (let Case (let V3488 (shen.lazyderef V3802 V3803) (if (= symbol V3488) (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V3801 V3803)) V3803 (freeze (fwhen (not (shen.ue? (shen.lazyderef V3801 V3803))) V3803 V3804)))) (if (shen.pvar? V3488) (do (shen.bindv V3488 symbol V3803) (let Result (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V3801 V3803)) V3803 (freeze (fwhen (not (shen.ue? (shen.lazyderef V3801 V3803))) V3803 V3804)))) (do (shen.unbindv V3488 V3803) Result))) false))) (if (= Case false) (let V3489 (shen.lazyderef V3801 V3803) (if (= () V3489) (let V3490 (shen.lazyderef V3802 V3803) (if (cons? V3490) (let V3491 (shen.lazyderef (hd V3490) V3803) (if (= list V3491) (let V3492 (shen.lazyderef (tl V3490) V3803) (if (cons? V3492) (let A (hd V3492) (let V3493 (shen.lazyderef (tl V3492) V3803) (if (= () V3493) (do (shen.incinfs) (thaw V3804)) (if (shen.pvar? V3493) (do (shen.bindv V3493 () V3803) (let Result (do (shen.incinfs) (thaw V3804)) (do (shen.unbindv V3493 V3803) Result))) false)))) (if (shen.pvar? V3492) (let A (shen.newpv V3803) (do (shen.bindv V3492 (cons A ()) V3803) (let Result (do (shen.incinfs) (thaw V3804)) (do (shen.unbindv V3492 V3803) Result)))) false))) (if (shen.pvar? V3491) (do (shen.bindv V3491 list V3803) (let Result (let V3494 (shen.lazyderef (tl V3490) V3803) (if (cons? V3494) (let A (hd V3494) (let V3495 (shen.lazyderef (tl V3494) V3803) (if (= () V3495) (do (shen.incinfs) (thaw V3804)) (if (shen.pvar? V3495) (do (shen.bindv V3495 () V3803) (let Result (do (shen.incinfs) (thaw V3804)) (do (shen.unbindv V3495 V3803) Result))) false)))) (if (shen.pvar? V3494) (let A (shen.newpv V3803) (do (shen.bindv V3494 (cons A ()) V3803) (let Result (do (shen.incinfs) (thaw V3804)) (do (shen.unbindv V3494 V3803) Result)))) false))) (do (shen.unbindv V3491 V3803) Result))) false))) (if (shen.pvar? V3490) (let A (shen.newpv V3803) (do (shen.bindv V3490 (cons list (cons A ())) V3803) (let Result (do (shen.incinfs) (thaw V3804)) (do (shen.unbindv V3490 V3803) Result)))) false))) false)) Case)) Case)) Case)) Case)))

(defun shen.by_hypothesis (V3810 V3811 V3812 V3813 V3814) (let Case (let V3476 (shen.lazyderef V3812 V3813) (if (cons? V3476) (let V3477 (shen.lazyderef (hd V3476) V3813) (if (cons? V3477) (let Y (hd V3477) (let V3478 (shen.lazyderef (tl V3477) V3813) (if (cons? V3478) (let V3479 (shen.lazyderef (hd V3478) V3813) (if (= : V3479) (let V3480 (shen.lazyderef (tl V3478) V3813) (if (cons? V3480) (let B (hd V3480) (let V3481 (shen.lazyderef (tl V3480) V3813) (if (= () V3481) (do (shen.incinfs) (identical V3810 Y V3813 (freeze (unify! V3811 B V3813 V3814)))) false))) false)) false)) false))) false)) false)) (if (= Case false) (let V3482 (shen.lazyderef V3812 V3813) (if (cons? V3482) (let Hyp (tl V3482) (do (shen.incinfs) (shen.by_hypothesis V3810 V3811 Hyp V3813 V3814))) false)) Case)))

(defun shen.t*-def (V3820 V3821 V3822 V3823 V3824) (let V3470 (shen.lazyderef V3820 V3823) (if (cons? V3470) (let V3471 (shen.lazyderef (hd V3470) V3823) (if (= define V3471) (let V3472 (shen.lazyderef (tl V3470) V3823) (if (cons? V3472) (let F (hd V3472) (let X (tl V3472) (let Y (shen.newpv V3823) (let E (shen.newpv V3823) (do (shen.incinfs) (shen.t*-defh (compile (lambda Y (shen.<sig+rules> Y)) X (lambda E (if (cons? E) (simple-error (cn "parse error here: " (shen.app E "
" shen.s))) (simple-error "parse error
")))) F V3821 V3822 V3823 V3824)))))) false)) false)) false)))

(defun shen.t*-defh (V3831 V3832 V3833 V3834 V3835 V3836) (let V3466 (shen.lazyderef V3831 V3835) (if (cons? V3466) (let Sig (hd V3466) (let Rules (tl V3466) (do (shen.incinfs) (shen.t*-defhh Sig (shen.ue-sig Sig) V3832 V3833 V3834 Rules V3835 V3836)))) false)))

(defun shen.t*-defhh (V3845 V3846 V3847 V3848 V3849 V3850 V3851 V3852) (do (shen.incinfs) (shen.t*-rules V3850 V3846 1 V3847 (cons (cons V3847 (cons : (cons V3846 ()))) V3849) V3851 (freeze (shen.memo V3847 V3845 V3848 V3851 V3852)))))

(defun shen.memo (V3858 V3859 V3860 V3861 V3862) (let Jnk (shen.newpv V3861) (do (shen.incinfs) (unify! V3860 V3859 V3861 (freeze (bind Jnk (declare (shen.lazyderef V3858 V3861) (shen.lazyderef V3860 V3861)) V3861 V3862))))))

(defun shen.<sig+rules> (V3864) (let Parse_shen.<signature> (shen.<signature> V3864) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<signature>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))))

(defun shen.<non-ll-rules> (V3866) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V3866) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<rule>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V3866) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.hdtl Parse_shen.<rule>) ())) (fail))) YaccParse)))

(defun shen.ue (V3868) (cond ((and (cons? V3868) (and (cons? (tl V3868)) (and (= () (tl (tl V3868))) (= (hd V3868) protect)))) V3868) ((cons? V3868) (map (lambda Z (shen.ue Z)) V3868)) ((variable? V3868) (concat && V3868)) (true V3868)))

(defun shen.ue-sig (V3870) (cond ((cons? V3870) (map (lambda Z (shen.ue-sig Z)) V3870)) ((variable? V3870) (concat &&& V3870)) (true V3870)))

(defun shen.ues (V3876) (cond ((shen.ue? V3876) (cons V3876 ())) ((cons? V3876) (union (shen.ues (hd V3876)) (shen.ues (tl V3876)))) (true ())))

(defun shen.ue? (V3878) (and (symbol? V3878) (shen.ue-h? (str V3878))))

(defun shen.ue-h? (V3886) (cond ((and (shen.+string? V3886) (and (= "&" (pos V3886 0)) (and (shen.+string? (tlstr V3886)) (= "&" (pos (tlstr V3886) 0))))) true) (true false)))

(defun shen.t*-rules (V3894 V3895 V3896 V3897 V3898 V3899 V3900) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V3450 (shen.lazyderef V3894 V3899) (if (= () V3450) (do (shen.incinfs) (thaw V3900)) false)) (if (= Case false) (let Case (let V3451 (shen.lazyderef V3894 V3899) (if (cons? V3451) (let Rule (hd V3451) (let Rules (tl V3451) (do (shen.incinfs) (shen.t*-rule (shen.ue Rule) V3895 V3898 V3899 (freeze (cut Throwcontrol V3899 (freeze (shen.t*-rules Rules V3895 (+ V3896 1) V3897 V3898 V3899 V3900)))))))) false)) (if (= Case false) (let Err (shen.newpv V3899) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V3896 V3899) (cn " of " (shen.app (shen.lazyderef V3897 V3899) "" shen.a)) shen.a))) V3899 V3900))) Case)) Case)))))

(defun shen.t*-rule (V3906 V3907 V3908 V3909 V3910) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V3442 (shen.lazyderef V3906 V3909) (if (cons? V3442) (let Patterns (hd V3442) (let V3443 (shen.lazyderef (tl V3442) V3909) (if (cons? V3443) (let Action (hd V3443) (let V3444 (shen.lazyderef (tl V3443) V3909) (if (= () V3444) (let NewHyps (shen.newpv V3909) (do (shen.incinfs) (shen.newhyps (shen.placeholders Patterns) V3908 NewHyps V3909 (freeze (shen.t*-patterns Patterns V3907 NewHyps V3909 (freeze (cut Throwcontrol V3909 (freeze (shen.t*-action (shen.curry (shen.ue Action)) (shen.result-type Patterns V3907) (shen.patthyps Patterns V3907 V3908) V3909 V3910))))))))) false))) false))) false)))))

(defun shen.placeholders (V3916) (cond ((shen.ue? V3916) (cons V3916 ())) ((cons? V3916) (union (shen.placeholders (hd V3916)) (shen.placeholders (tl V3916)))) (true ())))

(defun shen.newhyps (V3922 V3923 V3924 V3925 V3926) (let Case (let V3429 (shen.lazyderef V3922 V3925) (if (= () V3429) (do (shen.incinfs) (unify! V3924 V3923 V3925 V3926)) false)) (if (= Case false) (let V3430 (shen.lazyderef V3922 V3925) (if (cons? V3430) (let V3425 (hd V3430) (let Vs (tl V3430) (let V3431 (shen.lazyderef V3924 V3925) (if (cons? V3431) (let V3432 (shen.lazyderef (hd V3431) V3925) (if (cons? V3432) (let V (hd V3432) (let V3433 (shen.lazyderef (tl V3432) V3925) (if (cons? V3433) (let V3434 (shen.lazyderef (hd V3433) V3925) (if (= : V3434) (let V3435 (shen.lazyderef (tl V3433) V3925) (if (cons? V3435) (let A (hd V3435) (let V3436 (shen.lazyderef (tl V3435) V3925) (if (= () V3436) (let NewHyp (tl V3431) (do (shen.incinfs) (unify! V V3425 V3925 (freeze (shen.newhyps Vs V3923 NewHyp V3925 V3926))))) (if (shen.pvar? V3436) (do (shen.bindv V3436 () V3925) (let Result (let NewHyp (tl V3431) (do (shen.incinfs) (unify! V V3425 V3925 (freeze (shen.newhyps Vs V3923 NewHyp V3925 V3926))))) (do (shen.unbindv V3436 V3925) Result))) false)))) (if (shen.pvar? V3435) (let A (shen.newpv V3925) (do (shen.bindv V3435 (cons A ()) V3925) (let Result (let NewHyp (tl V3431) (do (shen.incinfs) (unify! V V3425 V3925 (freeze (shen.newhyps Vs V3923 NewHyp V3925 V3926))))) (do (shen.unbindv V3435 V3925) Result)))) false))) (if (shen.pvar? V3434) (do (shen.bindv V3434 : V3925) (let Result (let V3437 (shen.lazyderef (tl V3433) V3925) (if (cons? V3437) (let A (hd V3437) (let V3438 (shen.lazyderef (tl V3437) V3925) (if (= () V3438) (let NewHyp (tl V3431) (do (shen.incinfs) (unify! V V3425 V3925 (freeze (shen.newhyps Vs V3923 NewHyp V3925 V3926))))) (if (shen.pvar? V3438) (do (shen.bindv V3438 () V3925) (let Result (let NewHyp (tl V3431) (do (shen.incinfs) (unify! V V3425 V3925 (freeze (shen.newhyps Vs V3923 NewHyp V3925 V3926))))) (do (shen.unbindv V3438 V3925) Result))) false)))) (if (shen.pvar? V3437) (let A (shen.newpv V3925) (do (shen.bindv V3437 (cons A ()) V3925) (let Result (let NewHyp (tl V3431) (do (shen.incinfs) (unify! V V3425 V3925 (freeze (shen.newhyps Vs V3923 NewHyp V3925 V3926))))) (do (shen.unbindv V3437 V3925) Result)))) false))) (do (shen.unbindv V3434 V3925) Result))) false))) (if (shen.pvar? V3433) (let A (shen.newpv V3925) (do (shen.bindv V3433 (cons : (cons A ())) V3925) (let Result (let NewHyp (tl V3431) (do (shen.incinfs) (unify! V V3425 V3925 (freeze (shen.newhyps Vs V3923 NewHyp V3925 V3926))))) (do (shen.unbindv V3433 V3925) Result)))) false)))) (if (shen.pvar? V3432) (let V (shen.newpv V3925) (let A (shen.newpv V3925) (do (shen.bindv V3432 (cons V (cons : (cons A ()))) V3925) (let Result (let NewHyp (tl V3431) (do (shen.incinfs) (unify! V V3425 V3925 (freeze (shen.newhyps Vs V3923 NewHyp V3925 V3926))))) (do (shen.unbindv V3432 V3925) Result))))) false))) (if (shen.pvar? V3431) (let V (shen.newpv V3925) (let A (shen.newpv V3925) (let NewHyp (shen.newpv V3925) (do (shen.bindv V3431 (cons (cons V (cons : (cons A ()))) NewHyp) V3925) (let Result (do (shen.incinfs) (unify! V V3425 V3925 (freeze (shen.newhyps Vs V3923 NewHyp V3925 V3926)))) (do (shen.unbindv V3431 V3925) Result)))))) false))))) false)) Case)))

(defun shen.patthyps (V3932 V3933 V3934) (cond ((= () V3932) V3934) ((and (cons? V3932) (and (cons? V3933) (and (cons? (tl V3933)) (and (= --> (hd (tl V3933))) (and (cons? (tl (tl V3933))) (= () (tl (tl (tl V3933))))))))) (adjoin (cons (hd V3932) (cons : (cons (hd V3933) ()))) (shen.patthyps (tl V3932) (hd (tl (tl V3933))) V3934))) (true (shen.f_error shen.patthyps))))

(defun shen.result-type (V3941 V3942) (cond ((and (= () V3941) (and (cons? V3942) (and (= --> (hd V3942)) (and (cons? (tl V3942)) (= () (tl (tl V3942))))))) (hd (tl V3942))) ((= () V3941) V3942) ((and (cons? V3941) (and (cons? V3942) (and (cons? (tl V3942)) (and (= --> (hd (tl V3942))) (and (cons? (tl (tl V3942))) (= () (tl (tl (tl V3942))))))))) (shen.result-type (tl V3941) (hd (tl (tl V3942))))) (true (shen.f_error shen.result-type))))

(defun shen.t*-patterns (V3948 V3949 V3950 V3951 V3952) (let Case (let V3417 (shen.lazyderef V3948 V3951) (if (= () V3417) (do (shen.incinfs) (thaw V3952)) false)) (if (= Case false) (let V3418 (shen.lazyderef V3948 V3951) (if (cons? V3418) (let Pattern (hd V3418) (let Patterns (tl V3418) (let V3419 (shen.lazyderef V3949 V3951) (if (cons? V3419) (let A (hd V3419) (let V3420 (shen.lazyderef (tl V3419) V3951) (if (cons? V3420) (let V3421 (shen.lazyderef (hd V3420) V3951) (if (= --> V3421) (let V3422 (shen.lazyderef (tl V3420) V3951) (if (cons? V3422) (let B (hd V3422) (let V3423 (shen.lazyderef (tl V3422) V3951) (if (= () V3423) (do (shen.incinfs) (shen.t* (cons Pattern (cons : (cons A ()))) V3950 V3951 (freeze (shen.t*-patterns Patterns B V3950 V3951 V3952)))) false))) false)) false)) false))) false)))) false)) Case)))

(defun shen.t*-action (V3958 V3959 V3960 V3961 V3962) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V3394 (shen.lazyderef V3958 V3961) (if (cons? V3394) (let V3395 (shen.lazyderef (hd V3394) V3961) (if (= where V3395) (let V3396 (shen.lazyderef (tl V3394) V3961) (if (cons? V3396) (let P (hd V3396) (let V3397 (shen.lazyderef (tl V3396) V3961) (if (cons? V3397) (let Action (hd V3397) (let V3398 (shen.lazyderef (tl V3397) V3961) (if (= () V3398) (do (shen.incinfs) (cut Throwcontrol V3961 (freeze (shen.t* (cons P (cons : (cons boolean ()))) V3960 V3961 (freeze (cut Throwcontrol V3961 (freeze (shen.t*-action Action V3959 (cons (cons P (cons : (cons verified ()))) V3960) V3961 V3962)))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3399 (shen.lazyderef V3958 V3961) (if (cons? V3399) (let V3400 (shen.lazyderef (hd V3399) V3961) (if (= shen.choicepoint! V3400) (let V3401 (shen.lazyderef (tl V3399) V3961) (if (cons? V3401) (let V3402 (shen.lazyderef (hd V3401) V3961) (if (cons? V3402) (let V3403 (shen.lazyderef (hd V3402) V3961) (if (cons? V3403) (let V3404 (shen.lazyderef (hd V3403) V3961) (if (= fail-if V3404) (let V3405 (shen.lazyderef (tl V3403) V3961) (if (cons? V3405) (let F (hd V3405) (let V3406 (shen.lazyderef (tl V3405) V3961) (if (= () V3406) (let V3407 (shen.lazyderef (tl V3402) V3961) (if (cons? V3407) (let Action (hd V3407) (let V3408 (shen.lazyderef (tl V3407) V3961) (if (= () V3408) (let V3409 (shen.lazyderef (tl V3401) V3961) (if (= () V3409) (do (shen.incinfs) (cut Throwcontrol V3961 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons F (cons Action ())) ())) (cons Action ()))) V3959 V3960 V3961 V3962)))) false)) false))) false)) false))) false)) false)) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3410 (shen.lazyderef V3958 V3961) (if (cons? V3410) (let V3411 (shen.lazyderef (hd V3410) V3961) (if (= shen.choicepoint! V3411) (let V3412 (shen.lazyderef (tl V3410) V3961) (if (cons? V3412) (let Action (hd V3412) (let V3413 (shen.lazyderef (tl V3412) V3961) (if (= () V3413) (do (shen.incinfs) (cut Throwcontrol V3961 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons (cons = (cons Action ())) (cons (cons fail ()) ())) ())) (cons Action ()))) V3959 V3960 V3961 V3962)))) false))) false)) false)) false)) (if (= Case false) (do (shen.incinfs) (shen.t* (cons V3958 (cons : (cons V3959 ()))) V3960 V3961 V3962)) Case)) Case)) Case)))))

(defun findall (V3968 V3969 V3970 V3971 V3972) (let B (shen.newpv V3971) (let A (shen.newpv V3971) (do (shen.incinfs) (bind A (gensym shen.a) V3971 (freeze (bind B (set (shen.lazyderef A V3971) ()) V3971 (freeze (shen.findallhelp V3968 V3969 V3970 A V3971 V3972)))))))))

(defun shen.findallhelp (V3979 V3980 V3981 V3982 V3983 V3984) (let Case (do (shen.incinfs) (call V3980 V3983 (freeze (shen.remember V3982 V3979 V3983 (freeze (fwhen false V3983 V3984)))))) (if (= Case false) (do (shen.incinfs) (bind V3981 (value (shen.lazyderef V3982 V3983)) V3983 V3984)) Case)))

(defun shen.remember (V3989 V3990 V3991 V3992) (let B (shen.newpv V3991) (do (shen.incinfs) (bind B (set (shen.deref V3989 V3991) (cons (shen.deref V3990 V3991) (value (shen.deref V3989 V3991)))) V3991 V3992))))



